package com.example.android.guesstheword.screens.gameimport android.os.CountDownTimerimport android.text.format.DateUtilsimport android.util.Logimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.Transformationsimport androidx.lifecycle.ViewModelprivate val CORRECT_BUZZ_PATTERN = longArrayOf(100, 100, 100, 100, 100, 100)private val PANIC_BUZZ_PATTERN = longArrayOf(0, 200)private val GAME_OVER_BUZZ_PATTERN = longArrayOf(0, 2000)private val NO_BUZZ_PATTERN = longArrayOf(0)class GameViewModel: ViewModel() {    companion object {        const val DONE = 0L        const val ONE_SECOND = 1000L        const val COUNTDOWN_TIME = 60000L    }    enum class BuzzType(val pattern: LongArray) {        CORRECT(CORRECT_BUZZ_PATTERN),        GAME_OVER(GAME_OVER_BUZZ_PATTERN),        COUNTDOWN_PANIC(PANIC_BUZZ_PATTERN),        NO_BUZZ(NO_BUZZ_PATTERN)    }    private val timer: CountDownTimer    // The current word    val word: LiveData<String> = MutableLiveData<String>()    // The current score    val score: LiveData<Int> = MutableLiveData<Int>()    val eventGameFinish: LiveData<Boolean> = MutableLiveData<Boolean>()    private val timeRemaining: LiveData<Long> = MutableLiveData<Long>()    val timerText: LiveData<String> = Transformations.map(timeRemaining) { time ->        DateUtils.formatElapsedTime(time / 1000)    }    val buzzPattern: LiveData<BuzzType> = MutableLiveData<BuzzType>()        // The list of words - the front of the list is the next word to guess    private lateinit var wordList: MutableList<String>    init {        Log.i("GameViewModel", "GameViewModel created!");        resetList()        nextWord()        setBuzzPattern(BuzzType.NO_BUZZ)        setScore(0)        timer = object : CountDownTimer(COUNTDOWN_TIME, ONE_SECOND) {            override fun onTick(millisUntilFinished: Long) {                setTimeRemaining(millisUntilFinished);                if (millisUntilFinished <= ONE_SECOND * 10) {                    setBuzzPattern(BuzzType.COUNTDOWN_PANIC)                }            }            override fun onFinish() {                setEventGameFinish(true);                setBuzzPattern(BuzzType.GAME_OVER)            }        }.start()    }    private fun setWord(value: String) {        (word as MutableLiveData).value = value;    }    fun getScoreValue(): Int {        return score.value ?: 0    }    private fun setScore(value: Int) {        (score as MutableLiveData).value = value;    }    fun getWordList(): List<String> {        return wordList;    }    private fun setEventGameFinish(value: Boolean) {        (eventGameFinish as MutableLiveData).value = value    }    private fun setTimeRemaining(value: Long) {        (timeRemaining as MutableLiveData).value = value    }    private fun setBuzzPattern(value: BuzzType) {        (buzzPattern as MutableLiveData).value = value    }    /**     * Resets the list of words and randomizes the order     */    private fun resetList() {        wordList = mutableListOf(            "queen",            "hospital",            "basketball",            "cat",            "change",            "snail",            "soup",            "calendar",            "sad",            "desk",            "guitar",            "home",            "railway",            "zebra",            "jelly",            "car",            "crow",            "trade",            "bag",            "roll",            "bubble"        )        wordList.shuffle()    }    /**     * Moves to the next word in the list     */    private fun nextWord() {        //Select and remove a word from the list        if (wordList.isEmpty()) {            resetList()        }        setWord(wordList.removeAt(0));    }    fun onSkip() {        setScore(getScoreValue()- 1)        nextWord()    }    fun onCorrect() {        if (!wordList.isEmpty()) {            setScore(getScoreValue() + 1)            setBuzzPattern(BuzzType.CORRECT)        }        nextWord()    }    fun onGameFinishComplete() {        setEventGameFinish(false)    }    fun onBuzzComplete() {        setBuzzPattern(BuzzType.NO_BUZZ)    }    override fun onCleared() {        super.onCleared()        timer.cancel()        Log.i("GameViewModel", "GameViewModel Destroyed")    }}